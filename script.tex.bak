\documentclass[a4paper]{article}

%quasi-historischer Header:
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{scrextend}
%\usepackage{algorithm}
%\usepackage{algorithmicx}[noend]
\usepackage[noend]{algpseudocode}

\title{Flussnetzwerke \\ \medskip \large Proseminar Theoretische Informatik}
\author{Maximilian Starke \\ Student der TU Dresden \\ Fakultät Informatik}
\date{\today}

%\usepackage{wasysym}
\usepackage{mathtools}
\usepackage{ragged2e}

%\usepackage[pdftex]{hyperref}
\usepackage{framed}
%\usepackage{mdframed}

%\usepackage[inline, shortlabels]{enumitem}
\usepackage{amsmath, amssymb}
\usepackage{enumerate}
%\usepackage{multicol} % multiple collums in enumerate
%\usepackage{graphicx}
\usepackage{tabularx}


%\usepackage[thmmarks,amsmath,hyperref,noconfig]{ntheorem}
%\usepackage{listings}
%\usepackage{fancybox}
%\usepackage{tikz}
%\usepackage{struktex}

%\usepackage{array}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

%\usepackage{caption}
%\DeclareCaptionFont{white}{\color{white}}

\usepackage{listings}
%\usepackage{tcolorbox<}
%\tcbuselibrary{listings}
%\usepackage{minted}
%\tcbuselibrary{minted}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\flushleft\arraybackslash}m{#1}}


\usepackage{tikz}
\usepackage{verbatim}

\usetikzlibrary{%
	arrows,
	shapes,
	shapes.misc,% wg. rounded rectangle
	shapes.arrows,%
	chains,%
	matrix,%
	positioning,% wg. " of "
	backgrounds,
	fit,
	petri,
	scopes,%
	decorations.pathmorphing,% /pgf/decoration/random steps | erste Graphik
	shadows%
}

\tikzstyle{vertex}=[circle,fill=lime!90,minimum size=20pt,inner sep=0pt]
\tikzstyle{selected vertex} = [vertex, fill=red!24]
\tikzstyle{edge} = [draw,line width=1.8pt,->]
\tikzstyle{medge} = [draw, line width = 8pt, yellow!50]
\tikzstyle{weight} = [font=\small]
\tikzstyle{selected edge} = [draw,line width=5pt,-,red!50]
\tikzstyle{ignored edge} = [draw,line width=5pt,-,black!20]


\usepackage{xcolor}
% maybe install minted some day and make syntax highlighting###

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath, amssymb}
\usepackage{enumerate}
\usepackage{multicol} % multiple collums in enumerate

\usepackage[thmmarks,amsmath,hyperref,noconfig]{ntheorem} 
% erlaubt es, Sätze, Definitionen etc. einfach durchzunummerieren.
\newtheorem{satz}{Satz}[section] % Nummerierung nach Abschnitten
\newtheorem{proposition}[satz]{Proposition}
\newtheorem{korollar}[satz]{Korollar}
\newtheorem{lemma}[satz]{Lemma}

\theorembodyfont{\upshape}
\newtheorem{beispiel}[satz]{Beispiel}
\newtheorem{bemerkung}[satz]{Bemerkung}
\newtheorem{definition}[satz]{Definition} %[section]
\newtheorem{algorithmus}[satz]{Algorithmus}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.}
\theoremsymbol{\ensuremath{_\Box}}
\newtheorem{beweis}{Beweis}
\newtheorem{beweiss}{Beweisskizze}

\qedsymbol{\ensuremath{_\Box}}

\usepackage{chngcntr}
\counterwithin{figure}{section}

\tikzstyle{block} = [rectangle, draw, fill=blue!40, 
text width=7em, text centered, rounded corners, minimum height=5em, node distance= 4.5cm, line width = 2pt]


\tikzstyle{cblock} = [rectangle, draw, fill=blue!40, 
text width=7em, text centered, rounded corners, minimum height=5em, node distance= 3.0cm, line width = 2pt]


\tikzstyle{line} = [draw, -latex', line width = 1pt]


\tikzstyle{cloud} = [ fill = white, rectangle, draw, rounded corners, node distance=2cm,
minimum height=2.5em]

\pgfdeclarelayer{bg}
%\pgfsetlayers{bg,main}	

\pgfdeclarelayer{foreground}
\pgfdeclarelayer{background}
% tell TikZ how to stack them (back to front)
\pgfsetlayers{bg,background,main,foreground}


\def\ftup{$F= (V,E,c,s,t)$ }
\def\tab{\hspace{5ex}}

\begin{document}

\maketitle

\vspace{2cm}

\tableofcontents

\pagebreak

\section{Motivation}

Nahezu überall und jeden Tag begegnen uns Probleme, welche wir heute algorithmisch mit Computern lösen, anstatt sie mühselig per Hand zu rechnen, sofern dies überhaupt möglich wäre. Insbesondere zählen dazu viele Probleme, die sich auf diskrete Graphen, wie man sie aus der Mathematik kennt, zurückführen lassen. Unter einem Graphen versteht man eine Menge von Objekten, genannt Knoten, welche über sogenannte Kanten, verbunden sind. In dieser Arbeit widmen wir uns speziellen Graphen, sogenannten Flussnetzwerken. Flussnetzwerke beschreiben zusätzlich Kapazitäten, die den Kanten zugeordnet werden. Sowohl Landkarten als auch Netzwerke für Datenverkehr lassen sich beispielsweise als Flussnetzwerke darstellen. Die Kapazitäten beschreiben hierbei, wie viele Kraftfahrzeuge die Straße befahren, bzw. wie viele Datenpakete die Leitung passieren können.

Häufig sind Fragestellungen wie die Frage nach dem kürzesten Weg auf Landkarten oder nach dem Fassungsvermögen von bestimmten Straßennetzen von Interesse, um Geld zu sparen. Beim Ausbau von Datennetzen möchte man Engpässe, also die Stellen mit Ausbaubedarf ausfindig machen und nicht an Punkten ausbauen, wo es zunächst unnötig ist. Diese Probleme lassen sich unter \textit{Kostenminimierung} zusammenfassen.

Ein anderer interessanter Fall ist die \textit{Maximierung der Ausbeute}. Wir stellen uns zum Beispiel ein Datennetzwerk vor, in dem eine riesige Menge an Daten von A nach B transportiert werden muss. Dazu können die Daten parallel über mehrere Wege geleitet werden. Hier möchte man wissen, welche Routen die Daten nehmen müssen, damit man den größten Durchsatz erhält. Stellen wir uns als weiteres Beispiel eine Fabrik mit gewissen Maschinen und Robotern vor, die alle gewisse Arbeitsschritte erledigen können. Hier möchte man eine möglichst hohe Produktionsgeschwindigkeit erreichen, indem die Läufe der Zwischenprodukte von Maschine zu Maschine optimiert werden.

Um das Problem von der Maximierung der Ausbeute zu lösen, gibt es zahlreiche Algorithmen. Wir wollen in dieser Arbeit den \textit{Ford-Fulkerson-Algorithmus} und den \textit{Push-Relabel-Algorithmus} näher betrachten. Man nennt das Problem, welches diese Algorithmen lösen, auch das Maximum-Flow-Problem oder Problem des maximalen Flusses.

\section{Grundlagen}
Um ein Objektnetz mit unterscheidbaren Objekten  und gerichteten Verbindungslinien zwischen ihnen zu modellieren, definieren wir uns zunächst Graphen.
\subsection{Graphen und Flussnetzwerke}
\begin{definition}[Graph]
	Ein Graph $G$ ist ein Tupel $G = (V,E)$ aus einer endlichen Menge $V$, der Knotenmenge (\textit{engl. vertex für Knoten}) und einer Menge $E$ mit $E \subseteq V \times V$, der Kantenmenge (\textit{engl. edge für Kante}).
\end{definition}

\begin{definition}[Knotengrad, Inzidenz, Adjazenz]
	Es sei $G = (V,E)$ ein Graph. Dann nennen wir
	\[\mathrm{grad}(u) := \big|\{v \in V \mid (u,v) \in E\text{ oder } (v,u) \in E \}\big|\]
	den Knotengrad (kurz Grad) des Knotens $u$. Zwei Knoten $u,v \in V$ heißen zueinander adjazent, wenn $(u,v)$ oder $(v,u)$ eine Kante ist. Eine Kante und ein Knoten heißen zueinander inzident, wenn die Kante in dem Knoten beginnt oder dort endet.
\end{definition}

\label{sch1}%%% wird das gebraucht

	Für einen Graphen $G$ schreiben wir auch $\mathrm{V}(G)$ für dessen Knotenmenge und $\mathrm{E}(G)$ für dessen Kantenmenge. Um nun in solch einem Graphen, der beispielsweise kodieren kann, zwischen welchen Stationen ein Spediteur Lastwagen verkehren lässt, Transportwege darzustellen, definieren wir uns dazu Pfade wie folgt:
\begin{definition}[Pfad]
	Ein Pfad $p$ in einem Graphen $G$ ist ein Tupel $p=(p_0,p_1,\dots,p_{|p|-1})$ von Knoten $p_i \in \mathrm{V}(G)$, welche über Kanten verbunden sind: \[\forall i \in \{0,\dots,|p|-2\} : (p_i, p_{i+1}) \in \mathrm{E}(G)\]
\end{definition}

%\begin{beispiel}\label{bsp:graph}
Sehen wir uns dafür ein praktisches Beispiel an: Firma "`Schnell"' stellt Pakete in vier Städten zu und nimmt sie dort entgegen. Deshalb hat sie vier Paketzentren $V = \{1,2,3,4\}$ in den Städten eröffnet. Da die Städte mitten in einer Gebirgslandschaft verteilt liegen, kommen nur bestimmte Routen $E = \{(1,2),(2,3),(3,4),(4,1),(1,3)\}$ für Transportfahren zwischen den Städten in Frage. Abbildung \ref{abb:graph} zeigt den Graphen für dieses Netzwerk.

Familie Einhorn aus Stadt (1) möchte nun ein Paket an Familie Dreißt in Stadt (3) senden. Der gelb eingezeichnete Pfad stellt eine Möglichkeit für den Lauf des Paketes dar, bei welchem das Paket zunächst vom Paketzentrum (1) zu Paketzentrum (2) und im Anschluss zu Paketzentrum (3) geschickt wird. Es gibt im gegebenen Graphen auch einen direkten Pfad $(1,3)$, der auch hätte gewählt werden können. Es kann aber genauso das andere Extrem auftreten: Solche Pfade, wie wir sie definieren, lassen auch Umwege zu, bei welchen ein Knoten mehrmals besucht wird. So ist beispielsweise der Pfad $(1,3,4,1,2,3)$ genauso eine legitime Möglichkeit von (1) nach (3) zu gelangen.

Nun stellen wir uns ein anderes Beispiel vor, bei welchem wir in einem Graphen zusätzlich eine Ausbeute betrachten und dann maximieren wollen: Gegeben sei ein Netzwerk aus Gaspipelines, in welchem wir maximal viel Gas von Station A zu Station G transportieren möchten. Dabei gibt es Rohrleitungen zwischen verschiedenen Stationen, durch die unterschiedlich viel Gas strömen kann. Wir erweitern unser Modell wie folgt, indem wir Flussnetzwerke einführen:


\begin{figure}
	\begin{center}
	\begin{tikzpicture}[auto,swap]
	
	% First we draw the vertices
	\foreach \pos/\name in {{(0,2)/4}, {(0,0)/1}, {(2,0)/2}, {(2,2)/3}}
	\node[vertex] (\name) at \pos {$\name$};
	
	% Connect vertices with edges and draw weights
	\foreach \source/ \dest /\weight in {}
	\path[edge] (\source) -- node[weight] {$\weight$} (\dest);

	\foreach \source/ \dest /\weight in {1/2/5,2/3/1}
	\draw[medge] (\source) to[bend right] (\dest);
	
	\foreach \source/ \dest /\weight in {3/4/0,4/1/3,1/2/5,2/3/1}
	\draw[edge] (\source) to[bend right] (\dest);
	
	\foreach \source/ \dest /\weight in {1/3/8}
	\draw[edge] (\source) to[bend left] (\dest);
	
	%			\draw [edge] (3) to [out=30,in=80,looseness=6] node {$4$} (3);
\end{tikzpicture}
\end{center}
\caption{Graphen und Pfade}
\label{abb:graph}
\end{figure}

\newpage

\begin{definition}[Flussnetzwerk]\label{fnw}
	Ein Flussnetzwerk $F$ ist ein Tupel der Form $F = (V,E,c,s,t)$, für das gilt:
	\begin{itemize}
		\item $(V,E)$ ist ein Graph.
		\item $c$ ist eine Funktion $c:V\times V \to \mathbb{R}$. \hfill (Kapazitätsfunktion)
		\item $\forall e \in E : c(e) \geq 0$ \hfill (nichtnegative Kapazitäten)
		\item $\forall u,v \in V : (u,v) \notin E \Rightarrow c(u,v) = 0$
		\item $s\in V$, $t\in V$, $s\neq t$ \hfill (Quelle und Senke sind Knoten)
		\item $\forall u,v \in V : (u,v) \in E \Rightarrow (v,u) \notin E$ \hfill (keine antiparallelen Kanten)
		\item $\forall v \in V : (v,v) \notin E$ \hfill (Irreflexivität bzw. keine Schleifen)
		\item $\forall v \in V : \exists\text{ Pfad } p : \big( p_0 = s \;\land\; p_{|p|-1}= t\; \land\; \exists i \in \{0,\dots,|p|-1\} : p_i = v\big)$ \textcolor{white}{\_} \hfill (Zusammenhangsbedingung)
	\end{itemize}
		
\end{definition}

	Wir nennen $s$ die \textit{Quelle (source)} und $t$ die \textit{Senke (target)} des Flussnetzwerkes. In der Quelle entspringt das zu transportierende Medium und in der Senke verschwindet es wieder. Die Funktion $c$ (\textit{nach engl. capacity}) ordnen den einzelnen Kanten ihre Kapazitäten zu. Der Einfachheit halber für spätere Definitionen und Sätze definieren wir diese Funktion auf ganz $V \times V$, ordnen nichtexistenten Kanten $0$ zu und schließen negative Kapazitäten aus. Analog zu Graphen verwenden wir zu einem Flussnetzwerk $F$ die Schreibweisen $\mathrm{V}(F)$ bzw. $\mathrm{E}(F)$ sowie $\mathrm{c}(F)$, $\mathrm{s}(F)$, und $\mathrm{t}(F)$ für die Kapazitätsfunktion, Quelle bzw. Senke. Die drei letzten Bedingungen der Definition stellen zum einen sicher, dass der Graph keine Schleifen enthält und zusammenhängend ist, was in der praktischen Verwendung bzw. Interpretation der Flussnetzwerke seine Begründung findet. Zum anderen werden hier antiparallele Kanten verboten, weil dies uns die Beweise technisch etwas erleichtert, wenngleich die Mächtigkeit des Modells hinsichtlich der Betrachtung maximaler Flüsse damit nicht eingeschränkt wird.

\begin{beispiel}\label{bsp:fnw}
	Die Stationen $A$ bis $G$ eines Verteilungsnetzes für Gas  sind über Rohrleitungen  verbunden, in denen Gas jeweils in einer bestimmten Richtung transportiert werden kann. Die Rohre sind von unterschiedlicher Stärke und können entsprechend der Kantenbeschriftungen mehr oder minder viel Volumen Gas pro Zeit transportieren. Abbildung \ref{abb:fnw} zeigt das Flussnetzwerk mit den folgenden Eigenschaften und einer beispielhaften Kapazitätsfunktion auf:
	\begin{itemize}
		\item $V = \{A,B,C,D,E,F,G\}$
		\item $E=\{(A,B), (B,C), (B,D), (C,A), (C,F), (D,F), (E,C), (F,B), (F,G)\}$ % warum geht das nicht
		\item $s=A$ und $t=G$
	\end{itemize}
\end{beispiel}
\begin{figure}
\begin{center}
	\begin{tikzpicture}[auto,swap]
	% First we draw the vertices
	\foreach \pos/\name in {{(-4.5,-1)/A}, {(-2,1)/B}, {(0,3)/D}, {(-1,-1)/C}, {(2,-0.5)/E}, {(1,1)/F}, {(3,3)/G}}
	\node[vertex] (\name) at \pos {$\name$};
	
	
	% Connect vertices with edges and draw weights
	\foreach \source/ \dest /\weight in {C/A/1}
	\path[edge] (\source) -- (\dest);
	
	\foreach \source/ \dest /\weight in {B/C/3,C/F/5}
	\draw[edge] (\source) to[bend right] (\dest);
	
	\foreach \source/ \dest /\weight in {F/B/2,F/E/4,E/C/3, F/G/9,A/B/12,B/D/8,D/F/5}
	\draw[edge] (\source) to[bend left] (\dest);
	
	\foreach \source/ \dest /\weight in {C/A/1}
	\path[edge] (\source) -- node[weight] {$\weight$} (\dest);
	
	\foreach \source/ \dest /\weight in {B/C/3,C/F/5}
	\draw[edge] (\source) to[bend right] node[weight] {$\weight$} (\dest);
	
	\foreach \source/ \dest /\weight in {F/B/2,F/E/4,E/C/3, F/G/9,A/B/12,B/D/8,D/F/5}
	\draw[edge] (\source) to[bend left] node[weight] {$\weight$} (\dest);
	
	
	\draw[edge] (-5.5,-1) to (A);
	\draw[edge] (G) to (4,3);
	%	\draw [edge] (C) to [out=-70,in=-90] node {$4$} (G);
	\end{tikzpicture}
\end{center}
	\caption{Flussnetzwerk zu Beispiel \ref{bsp:fnw}}
	\label{abb:fnw}
\end{figure}

Nun kennen wir ein komplettes Gasrohrleitungssystem und wissen, wie viel Gas die einzelnen Rohre transportieren können. So kann zum Beispiel durch Rohr $(D,F)$ höchstens ein Fluss von $5$ fließen. Nun interessiert uns aber noch, wie viel Gas potentiell durch das gesamte Flussnetzwerk fließen kann. Dazu definieren wir uns sogenannte Flüsse, welche genau dies darstellen:

\subsection{Flüsse}
	\begin{definition}[Fluss]\label{fluss}
		Sei $F = (V,E,c,s,t)$ ein Flussnetzwerk. Eine Funktion $f : V \times V \to \mathbb{R}$ heißt genau dann ein Fluss in $F$, wenn sie die folgenden zwei Bedingungen erfüllt:
		\begin{itemize}
			\item $\forall u,v \in V : 0 \leq f(u,v) \leq c(u,v)$ \hfill (Kapazitätsbedingung)
			\item $\forall u \in V \setminus \{s,t\} : \sum\nolimits_{v\in V}f(v,u) = \sum\nolimits_{v\in V}f(u,v)$ \hfill (Flusserhaltung)
		\end{itemize}
	\end{definition}

Die Flusserhaltung stellt sicher, dass in jeden Knoten genau soviel hineinfließt wie auch wieder herausfließt und damit weder ein "`Überfluss"' noch ein "`Unterfluss"' entsteht. Andernfalls würde das ja heißen, dass entweder Gas an einem Kreuzungspunkt aus dem Leitungsnetz entweicht oder wie aus dem Nichts entsteht. Die Kapazitätsbedingung dagegen sorgt dafür, dass der Fluss über keine Kante mehr Transportmaterial schickt, als die Kapazität der Kante zulässt.

\begin{beispiel}\label{bsp:fluss}
	Abbildung \ref{abb:fluss} zeigt einen möglichen Fluss im Flussnetzwerk aus Abbildung \ref{abb:fnw}. Alle Kanten $(u,v)$ sind dabei mit Fluss und Kapazität in der Form $f(u,v)\;/\;c(u,v)$ beschriftet. Die vom Fluss genutzten Kanten sind zu\-sätz\-lich hervorgehoben. So fließen beispielsweise auf Kante $(B,D)$ fünf Einheiten von Knoten $B$ nach Knoten $D$, also drei Einheiten weniger als die modellierte Gasleitung maximal transportieren kann.
\end{beispiel}

% noch markieren
\begin{figure}
	\begin{center}
		\begin{tikzpicture}[auto,swap]
			
		% First we draw the vertices
		\foreach \pos/\name in {{(-4.5,-1)/A}, {(-2,1)/B}, {(0,3)/D}, {(-1,-1)/C}, {(2,-0.5)/E}, {(1,1)/F}, {(3,3)/G}}
		\node[vertex] (\name) at \pos {$\name$};
		
		\draw[white, line width=3pt, loosely dotted] (-2.5,-1.5) -- (2.5,3.5);
				
		% Connect vertices with edges and draw weights
		\foreach \source/ \dest/ \begf / \endf in {C/A/3/3}
		\path[medge] (\source) -- (\dest);
		
		
		\foreach \source/ \dest /\weight/ \flow/ \begf / \endf in {C/A/1/1/1/3}
		\path[edge] (\source) -- node[weight] {$\flow$/$\weight$} (\dest);
		
		\foreach \source/ \dest /\weight/ \flow/ \begf / \endf in {B/C/3/3/2/2,C/F/5/2/7/7}
		\draw[medge] (\source) to[bend right] (\dest);
		
		\foreach \source/ \dest /\weight/ \flow/ \begf / \endf in {B/C/3/3/1/2,C/F/5/2/1/7}
		\draw[edge] (\source) to[bend right] node[weight] {$\flow$/$\weight$} (\dest);
		
		\foreach \source/ \dest / \begf / \endf in {F/G/9/9,A/B/1/1,B/D/4/4,D/F/5/5}
		\draw[medge] (\source) to[bend left] (\dest);
		
		\foreach \source/ \dest /\weight/ \flow/ \begf / \endf in {F/G/9/7/1/9,A/B/12/8/1/1,B/D/8/5/1/4,D/F/5/5/1/5,F/B/2/0/1/6,F/E/4/0/1/8,E/C/3/0/1/8}
		\draw[edge] (\source) to[bend left] node[weight] {$\flow$/$\weight$} (\dest);
		
			
		
		\draw[edge] (-5.5,-1) to (A);
		\draw[edge] (G) to (4,3);
		
		%	\draw [edge] (C) to [out=-70,in=-90] node {$4$} (G);
		\end{tikzpicture}
	\end{center}
\caption{Flussnetzwerk und Fluss zu Beispiel \ref{bsp:fluss}}
\label{abb:fluss}
\end{figure}

Zu einem jeden Fluss möchten wir natürlich wissen, wie viel Material er "`insgesamt"' von der Quelle zur Senke transportiert. Diese Größe nennen wir den Wert des Flusses und definieren sie wie folgt, indem wir einfach den aus der Quelle herausfließenden Fluss aufsummieren und Rückflüsse abziehen:

\begin{definition}
	Der Wert $\mathrm{value}(f)$ eines Flusses $f$ in einem Flussnetzwerk $F$ ist definiert als:
	\[
	\mathrm{value}(f) := \sum\limits_{v\in V}f(s(F),v) - \sum\limits_{v\in V}f(v,s(F))
	\]
\end{definition}

Die zentrale Fragestellung aus der Motivation war es, die Ausbeute zu maximieren. Wir nennen dieses Problem das \textbf{Maximum-Flow-Problem} und formalisieren dieses nun: Gegeben ist ein Flussnetzwerk $F=(V,E,c,s,t)$ und gesucht ist ein maximaler Fluss $f$ in F, der wie folgt definiert wird:

\begin{definition}[maximaler Fluss]
	Ein Fluss $f$ heißt genau dann ein maximaler Fluss in einem Flussnetzwerk $F$, wenn für alle Flüsse $g$ in $F$ gilt: \[\mathrm{value}(f) \geq \mathrm{value}(g)\]
\end{definition}

\subsection{Residualgraphen}

Bis jetzt kennen wir Flussnetzwerke und Flüsse in solchen. Was uns noch fehlt, um die Algorithmen zum Lösen des Maximum-Flow-Problems zu verstehen, ist die Betrachtung der Differenzwerte zu den Kanten, um die der Fluss auf diesen Kanten maximal erhöht oder verringert werden darf, ohne die Kapazitätsbedingung aus Definition \ref{fluss} zu verletzen. Dazu definieren wir uns den Residualgraphen, in deutscher Literatur manchmal auch unter dem Begriff Restgraphen zu finden:

\begin{definition}[Residualgraph]\label{resgraph}
	Sei $F = (V,E,c,s,t)$ ein Flussnetzwerk und $f$ ein Fluss in $F$. Dann schreiben wir $F_f$ für den Residualgraphen von $F$ mit dem Fluss $f$. Der Residualgraph ist ein Tupel $F_f := (V_r,E_r,c_r)$ mit 
	\begin{itemize}
		\item  $V_r := V$,
		\item  $c_r(u,v) :=  c(u,v) - f(u,v) + f(v,u)$ und
		\item  $E_r := \{(u,v) \in V^2 \mid c_r(u,v) > 0\}$
	\end{itemize}
\end{definition}

Sofern $(u,v)$ Kante im ursprünglichen Flussnetzwerk ist, so ergibt sich ihre Residualkapazität als Differenz aus der Kapazität der Kante $c(u,v)$ und dem tatsächlichen Fluss auf dieser Kante $f(u,v)$, weil in diesem Fall $f(v,u)=0$ sein muss, da die Kante $(v,u)$ für diesen Fall laut Definition \ref{fnw} im Flussnetzwerk nicht existiert. Gab es die Kante $(u,v)$ im ursprünglichen Netzwerk nicht, so sind $c(u,v) = f(u,v) = 0$ und die Restkapazität entspricht dem Fluss, welches man von $u$ nach $v$ zurückschicken darf, weil $f$ ihn zuvor über die Kante $(v,u)$ von $v$ nach $u$ transportierte. Die Definition erlaubt den Fall, dass der Residualgraph antiparallele Kanten aufweist. Dies tritt nebenbei bemerkt genau dann ein, wenn der Fluss $f$ auf einer Kante einen Wert größer $0$ aber kleiner als die Kapazität im Flussnetzwerk annimmt, weil sich der Fluss dann auf dieser Kante sowohl erhöhen, als auch verringern ließe.

\begin{figure}
	\begin{center}
			\begin{tikzpicture}[auto,swap]
		
		% First we draw the vertices
		\foreach \pos/\name in {{(-4.5,-1)/A}, {(-2,1)/B}, {(0,3)/D}, {(-1,-1)/C}, {(2,-0.5)/E}, {(1,1)/F}, {(3,3)/G}}
		\node[vertex] (\name) at \pos {$\name$};
		
		
		% Residualkanten
		\foreach \source/ \dest /\weight/ \begf / \endf in {A/B/4/2/\last,B/A/8/2/\last,B/D/3/5/\last,D/B/5/5/\last,C/F/3/8/\last,F/C/2/8/\last,F/E/4/9/\last,E/C/3/9/\last,F/G/2/10/\last,G/F/7/10/\last}
		\draw[edge] (\source) to[bend left] node[weight] {$\weight$} (\dest);
		
		\foreach \source/ \dest /\weight/ \begf / \endf in {C/B/3/3/\last,A/C/1/4/\last,F/D/5/6/\last,F/B/2/7/\last}
		\path[edge] (\source) -- node[weight] {$\weight$} (\dest);
		
		
		\draw[edge] (-5.5,-1) to (A);
		\draw[edge] (G) to (4,3);
		
		%	\draw [edge] (C) to [out=-70,in=-90] node {$4$} (G);
		\end{tikzpicture}
	\end{center}
	\caption{Residualgraph zu Beispiel \ref{bsp:resgraph}}
	\label{abb:resgraph}
\end{figure}


\begin{beispiel}\label{bsp:resgraph}
	Abbildung \ref{abb:resgraph} zeigt den Residualgraphen zu Flussnetzwerk und Fluss aus Abbildung \ref{abb:fluss}. Schauen wir uns in Bezug auf unsere Bemerkung drei verschiedene Knotenpaare und die zwischen diesen abgebildeten Residualkanten an: Zwischen den Knoten $A$ und $B$ existiert für jede Richtung eine Kante, da $f$ ursprünglich $4$ von $12$ möglichen Einheiten von $A$ nach $B$ transportiert und sich in beide Richtungen Material schicken ließe. Zwischen den Knoten $B$ und $C$ existiert nur genau eine Kante, die in $C$ beginnt und in $D$ endet, weil $f$ die Kapazität der urspünglichen Kante $(B,C)$ ausgereizt hat. Die Kante $(F,B)$ des ursprünglichen Flussnetzwerkes hingegen wird vom Fluss nicht genutzt und erscheint daher im Residualgraphen als einzige Kante zwischen $B$ und $F$.
\end{beispiel}

Wir stellen schnell fest, dass obgleich antiparallele Kanten auftreten können, alle Kantengewichte im Residualgraphen nichtnegativ sind:

\begin{korollar}
	Sei $G = (V_r,E_r,c_r)$ ein Residualgraph. Dann gilt $\forall u,v \in V_r : c_r(u,v) \geq 0$.
\end{korollar}
\begin{beweis}
	Die Aussage folgt direkt aus der Definition \ref{resgraph} und der Kapazitäts\-be\-dingung aus Definition \ref{fluss}. Sei $c$ die Kapazitätsfunktion des ursprünglichen Flussnetzwerkes, aus welchem der Residualgraph berechnet wurde und $f$ der zugehörige Fluss. Aus Definition \ref{resgraph} folgt, da Flüsse nichtnegativ sind, $c_r(u,v) \geq c(u,v) - f(u,v)$. Aus der Kapazitätsbedingung folgt außerdem $f(u,v) \leq c(u,v)$ und damit die Aussage.
\end{beweis}

\section{Die Ford-Fulkerson-Methode}

Die Ford-Fulkerson-Methode ist ein Algorithmentemplate, eine Algorithmenschablone oder \textit{noch anders genannt} eine Menge von Algorithmen zur Lösung des Problems maximaler Flüsse, da sie in gewissem Sinne einen Rahmen zur Abarbeitung von Anweisungen darstellt, letztendlich aber an einer Stelle keine Reihenfolge oder Auswahlstrategie vorgibt, sondern diese offen lässt. Diese Methode gilt als das klassische Lösungsverfahren. Ford-Fulkerson betrachtet stets gültige Flüsse, beginnend mit dem Fluss $f$ mit $\mathrm{value}(f) = 0$, wo auf keiner Kante etwas fließt, und sucht wiederholt nach Pfaden, entlang welchen es möglich ist, den Fluss zu erhöhen, um jeweils einen neuen, verbesserten Fluss zu berechnen. Findet die Methode keine verbessernden Pfade mehr, so hat sie einen maximalen Fluss gefunden, wie später bewiesen wird.

\subsection{Korrektheitsbeweis}
%meta
Im Folgenden wird der Korrektheitsbeweis für die Ford-Fulkerson-Methode grob dargelegt. Besonders soll dabei die Struktur des Beweises zur Geltung kommen, die einzelnen Lemmata werden oft mit einer Beweisskizze kurz begründet und nur an ausgewählten Stellen der Anschaulichkeit wegen ausführlich bewiesen, da ein vollständiger Beweis an jeder Stelle den Rahmen dieser Arbeit sprengen würde.

\begin{definition}[Residualfluss]\label{rfluss}
	Seien $G = (V,E,c)$ ein Residualgraph und $s,t$ die Quelle bzw. Senke im ursprünglichen Flussnetzwerk. Dann definieren wir analog zu Definition \ref{fluss} (Fluss) einen Residualfluss $f_r$ im Residualgraphen: $f_r : V \times V \to \mathbb{R}$ sei eine Funktion, für die die Kapazitätsbedingung und die Flusserhaltung aus Definition \ref{fluss} gilt.
\end{definition}

\begin{definition}[Augmentation, Flussverbesserung]\label{augm}
	Sei $F$ ein Flussnetzwerk, $f$ ein Fluss in $F$ und $f_r$ ein Residualfluss in $F_f$. Dann sei die Operation $\uparrow$ (Augmentation oder Flussverbesserung) definiert mit

\[
(f \uparrow f_r)(u,v) :=
		\begin{cases}
	 f(u,v) + f_r(u,v) - f_r(v,u) 			& \forall (u,v) \in \mathrm{E}(F)\\
	 0										& \forall (u,v) \notin \mathrm{E}(F)
	\end{cases}
\]
\end{definition}

Zunächst definierten wir eine Art Fluss in Residualgraphen. Diesen "`addieren"' wir mit $\uparrow$ zu einem Fluss hinzu. Nun lässt sich erahnen, dass bei dieser Augmentation wieder ein Fluss errechnet wird. Das wollen wir nun zeigen:

\begin{lemma}[Abgeschlossenheit der Flussverbesserung]\label{abfluss}
	Sei \\ $F = (V,E,c,s,t)$ ein Flussnetzwerk, $f$ ein Fluss in $F$ und $f_r$ ein Residualfluss in $F_f$. Dann ist $f \uparrow f_r$ ein Fluss in $F$ und es gilt:
	\[
	\mathrm{value}(f \uparrow f_r) = \mathrm{value}(f) + \mathrm{value}(f_r)
	\]
	
\end{lemma}

\begin{beweiss}
Die Korrektheit von Lemma \ref{abfluss} lässt sich leicht vorstellen: Im Residualgraphen haben wir mögliche Flussänderungen modelliert und dabei die Kapazitäten im ursprünglichen Flussnetzwerk beachtet. Ein Residualfluss $f_r$ ist dann eine konkrete Möglichkeit, den Fluss zu verbessern. Dieser hält Restkapazitäten und Flusserhaltung ein und kann daher addiert zum Fluss $f$ nichts anderes als einen gültigen Fluss produzieren. Die Aussage kann formal aus Definition \ref{fluss} und \ref{rfluss} über Umformung einiger Gleichungen und Ungleichungen gezeigt werden.
\end{beweiss}

\begin{lemma}[Pfad-Residualfluss-Lemma]\label{prl}
	Sei $p$ ein Pfad in einem Residualgraph $F_f=(V,E,c)$ mit $p_0={\rm s}(F)$ und $p_{|p|-1} = {\rm t}(F)$, also ein Pfad von der Quelle zur Senke, genannt augmentierender Pfad. Dann ist $f_r$ mit
\[
	f_r(u,v) := \begin{cases}
		{\rm c}(p) & \exists i \in \{0, \dots , |p|-2\} : (u,v) = (p_i,p_{i+1}) \\
		0 & \text{\rm sonst}
	\end{cases}
\]
ein Residualfluss in $F_f$, genannt der von $p$ induzierte Residualfluss, wobei sich ${\rm c}(p)$ aus der kleinsten entlang des Pfades $p$ auftretenden Kapazität ergibt:
\[
	c(p) := min \big\{ \; c(p_i,p_{i+1}) \mid i \in \{0, \dots |p|-2\}\;\big\}
\] 
\end{lemma}

\begin{beweis}
	Die Aussage folgt unmittelbar mit Blick auf Definition \ref{rfluss}. Flusserhaltung und Kapazitätsbedingung werden erfüllt.
\end{beweis}

\begin{korollar}[Korollar von der Flussvergrößerung]\label{f++}
	Sei $F$ ein Flussnetzwerk, $f$ ein Fluss in $F$ und $f_r$ ein von einem Pfad $p$ im Residualgraphen $F_f$ induzierter Residualfluss. Dann gilt $\mathrm{value}(f \uparrow f_r) > \mathrm{value}(f)$.
\end{korollar}

\begin{beweis}
	Die Aussage folgt unmittelbar aus Lemmata \ref{abfluss} und \ref{prl}. Der Flusswert $\mathrm{value}(f_r)$ muss positiv sein, da $p$ wegen Definition \ref{resgraph} (Residualgraph) nur Kanten mit positivem Gewicht enthalten kann. 
\end{beweis}

Wir fassen einmal zusammen: Aus einem augmentierenden (flussverbessernden) Pfad im Residualgraphen lässt sich (Lemma \ref{prl}) ein Residualfluss induzieren, der sich zum aktuellen Fluss (Definition \ref{augm}) addieren lässt, sodass (Lemma~\ref{abfluss}) wieder ein Fluss entsteht, der echt größer ist als der Fluss zuvor (Korollar~\ref{f++}). Als nächstes wollen wir die Möglichkeit betrachten, das Flussnetzwerk in zwei Teile zu zerschneiden:

\begin{definition}[Schnitt, Netzfluss, Kapazität]\label{snk}
	Sei \ftup ein Flussnetzwerk. Ein Schnitt in $F$ ist eine spezielle Bipartition von $V$, nämlich ein Paar $(S,T)$ zweier Mengen $S,T \subseteq V$, für die gilt:
	\begin{itemize}
		\item $S \cup T = V$ und $S \cap T = \emptyset$
		\item $s \in S$ und $t \in T$
	\end{itemize}

	Sei $f$ ein Fluss in $F$. Dann ist der Netzfluss $f(S,T)$ durch den Schnitt $(S,T)$ definiert als
	\[
		f(S,T) := \sum\limits_{u \in S}\sum\limits_{v \in T} \big(f(u,v) - f(v,u)\big)\text{.}
	\]
	Außerdem definieren wir die Kapazität von Schnitten wie folgt:
	\[
	c(S,T) := \sum\limits_{u \in S}\sum\limits_{v \in T} c(u,v)
	\]
\end{definition}

\begin{lemma}[Flusswert = Netzfluss]\label{fnfl}
	Sei $F$ ein Flussnetzwerk, $f$ ein Fluss in $F$ und $(S,T)$ ein Schnitt in $F$. Dann ist der Netzfluss des Schnittes $(S,T)$ gleich dem Wert des Flusses $f$: \[f(S,T) = \mathrm{value}(f)\]
\end{lemma}

\begin{beweiss}
	Wenn ein Flussnetzwerk samt Fluss an einer Stelle auseinandergeschnitten wird, dann kann i.A. durch die durchgeschnittenen Transportkanten Material von $S$ nach $T$ und über einige Kanten auch von $T$ nach $S$ fließen. Da in allen Knoten außer Quelle und Senke Flusserhaltung gefordert wird, muss letztlich der Fluss, welches von der Quelle zur Senke fließt, von $S$ nach $T$ (nach allen Abzügen durch Fluss von $T$ nach $S$) durch den Schnitt $(S,T)$ fließen. Formal lässt sich dies mittels einiger Gleichungen mit Summen unter Nutzung der Fluss\-er\-hal\-tung aus Definition \ref{fluss} (Fluss) herleiten.
\end{beweiss}

\begin{lemma}[Schnitte als obere Schranken]\label{schnitt-schranke}
	Es sei $F$ ein Flussnetzwerk, $f$ ein Fluss und $(S,T)$ ein Schnitt in diesem Netzwerk. Dann gilt:
	\[ \mathrm{value}(f) \leq c(S,T)\]
\end{lemma}

\begin{beweis}
	\begin{align*}
		\mathrm{value}(f) & = & f(S,T) && \text{(Lemma \ref{fnfl})} \\
		& = & \sum\limits_{u \in S}\sum\limits_{v \in T} \big(f(u,v) - f(v,u)\big)  && \text{(Definition \ref{snk})} \\
		& \leq & \sum\limits_{u \in S}\sum\limits_{v \in T} f(u,v) && \text{(Definition \ref{fluss})} \\
		& \leq & \sum\limits_{u \in S}\sum\limits_{v \in T} c(u,v) && \text{(Definition \ref{fluss})} \\
		& = & c(S,T) && \text{(Definition \ref{snk})} \\
	\end{align*}
\end{beweis}

Jetzt wissen wir, dass an einem beliebigen Schnitt der Fluss durch den Schnitt (Netzfluss) dem Wert des Flusses im Flussnetzwerk entspricht. Weil der Netzfluss durch die Kapazität des Schnittes beschränkt ist, ist jeder Fluss durch jede Schnittkapazität beschränkt. Damit kennen wir alle Grundlagen, um den finalen Satz an dieser Stelle ausführlich zu beweisen:


\begin{satz}[Max-Flow Min-Cut Theorem]\label{mfmct}
	Sei $F=(V,E,c,s,t)$ ein Flussnetzwerk und $f$ ein Fluss in $F$. Dann sind folgende Aussagen äquivalent:
	\begin{enumerate}[(1)]
		\item $f$ ist ein maximaler Fluss in $F$.
		\item $F_f$ enthält keinen augmentierenden Pfad.
		\item Es gibt einen Schnitt $(S,T)$ mit $\mathrm{value}(f)= c(S,T)$.
	\end{enumerate}
\end{satz}

\begin{beweis}
	Wir verwenden im Folgenden die Bezeichner $V_r,E_r,c_r$ und meinen damit die Komponenten des Residualgraphen $F_f = (V_r,E_r,c_r)$.
	
	(1) $\Rightarrow$ (2):
	Angenommen, es gäbe einen augmentierenden Pfad in $F_f$. Dann gibt es nach Lemma \ref{prl} einen Residualfluss $f_r$ in $F_f$, dessen Wert positiv ist. Mit Lemma \ref{abfluss} erhalten wir aus $f \uparrow f_r$ einen größeren Fluss als $f$, ein Widerspruch.
	
	(2) $\Rightarrow$ (3):
	Wir gehen von (2) aus und konstruieren einen Schnitt, wie (3) ihn beschreibt. 
	Sei $S:= \{ v \in V \mid \text{Es gibt einen Pfad von s nach v in }F_f\}$ die Menge aller in $F_f$ von der Quelle aus erreichbaren Knoten. Dann ist $(S,V\setminus S)$ ein Schnitt, denn per Definition gilt $s \in S$ und wegen (2) auch $t \notin S$.
	Betrachten wir nun ein Knotenpaar $(u,v) \in S \times T$: Falls $(u,v) \in E$, dann gilt $f(u,v) = c(u,v)$, denn sonst wäre $(u,v)$ eine Residualkante, dann wäre aber $v \in S$. Falls $(v,u) \in E$, dann gilt $f(v,u)=0$, denn sonst wäre wieder $(u,v)$ eine Residualkante.
	Wenn keiner der beiden Fälle auftritt, ist trivialerweise $c(u,v) = c(v,u) = 0$ und der Fluss auf diesen Nicht-Kanten ist null.
	Damit erhalten wir
	\begin{align*}
		\mathrm{value}(f) & = & f(S,T) && \text{(Lemma \ref{fnfl})}\\
		& = & \sum\limits_{u \in S}\sum\limits_{v \in T} \big(f(u,v) - f(v,u)\big) && \text{(Definition \ref{snk})}\\
		& = & \sum\limits_{u \in S}\sum\limits_{v \in T} \big(c(u,v) - 0\big) && \text{(vorangegangene Fallunterscheidung)} \\
		& = & c(S,T) && \text{(Definition \ref{snk})}\\
	\end{align*}
	und haben mit $(S,T)$ solch einen gesuchten Schnitt gefunden.
	
	(3) $\Rightarrow$ (1):
	Sei $f'$ ein beliebiger Fluss in $F$.
	Laut Lemma \ref{schnitt-schranke} ist jeder Schnitt repräsentiert durch seine Kapazität eine obere Schranke für einen jeden Fluss:
	\begin{align*}
		& \mathrm{value}(f') \leq c(S,T) && \text{(Lemma \ref{schnitt-schranke})} \\
		\implies\hspace{2ex} & \mathrm{value}(f') \leq \mathrm{value}(f) && (\mathrm{value}(f)= c(S,T) \text{ wegen (3)})
	\end{align*}
	Also ist $f$ maximal.
\end{beweis}

\subsection{Anweisungsvorschrift}

\algrenewcommand{\algorithmicwhile}{\textbf{Solange}}
\algrenewcommand{\algorithmicforall}{\textbf{F{\"u}r alle}}
\algrenewcommand{\algorithmicend}{\textbf{Ende}}
\algrenewcommand{\algorithmicdo}{\textbf{:}}
\algrenewcommand{\algorithmicif}{\textbf{Falls}}
\algrenewcommand{\algorithmicelse}{\textbf{sonst}}
\algrenewcommand{\algorithmicthen}{\textbf{dann}}
\algrenewcommand{\algorithmicprocedure}{\textbf{Prozedur}}

\begin{figure}
	\begin{framed}
		\begin{algorithmic}[1]
			\ForAll{Kanten $(u,v) \in E$}
			\State $f(u,v):= 0$
			\EndFor
			\While{ein Pfad $p$ von $s$ nach $t$ in $F_f$ existiert}
			\State [Wähle einen solchen Pfad $p$ aus.]
			\State $c_f(p) := min \{c_f(u,v) \mid (u,v)\text{ liegt in }p\}$
			\ForAll{Kanten $(u,v)$ entlang des Pfades $p$}
			\If{$(u,v) \in E$}
			\State $f(u,v) := f(u,v) + c_f(p)$
			\Else \State $f(v,u) := f(v,u) - c_f(p)$
			\EndIf
			\EndFor
			\EndWhile
		\end{algorithmic}
		
	\end{framed}
	\caption{FORD-FULKERSON}
	\label{abb:ff}
\end{figure}

Wir wissen nun aus dem vorangegangenen Satz \ref{mfmct}, dass wir einen maximalen Fluss $f$ in einem Flussnetzwerk $F$ erhalten haben, wenn es keine flussverbessernden Pfade mehr im Residualgraph $F_f$ gibt. Also könnten wir solange nach neuen verbessernden Pfaden suchen, bis wir keine mehr finden. Und genau das realisiert die Methode von Ford-Fulkerson.

Abbildung \ref{abb:ff} zeigt den Pseudocode für die Ford-Fulkerson-Methode. In den ersten zwei Zeilen wird der Fluss so initialisiert, dass zu Beginn nichts fließt. In den drei darauffolgenden Zeilen bestimmen wir einen augmentierenden Pfad und die kleinste Kapazität entlang des Pfades. Um den Wert dieser Kapazität können wir nun in den Zeilen 6 bis 10 den Fluss verbessern. Mit dem Max-Flow Min-Cut Theorem ist gezeigt, dass Ford-Fulkerson bei Terminierung einen maximalen Fluss berechnet hat.
Um den Beweis zusammenzufassen, zeigt Abbildung \ref{abb:bstructff} noch einmal welche Sätze bzw. Lemmata auf welchen anderen aufbauen.
\begin{figure}
\begin{center}
	\begin{tikzpicture}[node distance = 1cm, auto]
	
	\node [cloud] at (0.5,1.5) (mfmc) {Max Flow - Min Cut Theorem};
	
	\node [cloud] at (-3.2,3.2) (fnf) {Flusswert = Netzfluss};
	\path [line] (mfmc) -- (fnf);
	
	\node [cloud] at (-5,1.7) (sos) {Schnitte als obere Schranken};
	\path [line] (mfmc) -- (sos);
	\path [line] (sos) -- (fnf);
	
	\node [cloud] at (2.2,2.8) (prl) {Pfad-Residualfluss-Lemma};
	\path [line] (mfmc) -- (prl);
	
	\node [cloud] at (-1.5,4.3) (adf) {Abgeschlossenheit der Flussvergrößerung};
	\path [line] (mfmc) -- (adf);
	
	\end{tikzpicture}
	
\end{center}
\caption{Die Beweisstruktur zu Ford-Fulkerson}
\label{abb:bstructff}
\end{figure}

\section{Die Push-Relabel-Methode}

Die Push-Relabel-Methode ist eine der schnellsten bis heute bekannten Methoden zur Lösung des Maximum-Flow-Problems und Basis für einige Implementierungen, die heutzutage in der Praxis verwendet werden. Im Gegensatz zu Ford-Folkerson betrachtet diese Methode immer einen Knoten und dessen unmittelbare Nachbarknoten. Dabei rechnet Push-Relabel nicht mit gültigen Flüssen, sondern mit sogenannten Vorausflüssen:

\begin{definition}[Vorausfluss]
	Ein Vorausfluss ist eine Funktion $f: V \times V \to \mathbb{R}$, für die gilt:
	\begin{itemize}
			\item $\forall u,v \in V : 0 \leq f(u,v) \leq c(u,v)$ \hfill (Kapazitätsbedingung)
			\item $\forall u \in V\setminus \{s\} : \sum\nolimits_{v\in V}f(v,u) - \sum\nolimits_{v\in V}f(u,v) \geq 0$ \hfill (Überlauf $\geq0$)
	\end{itemize}
\end{definition}

Im Vergleich zu Definition \ref{fluss} (Fluss) wird beim Vorausfluss keine Flusserhaltung gefordert. Stattdessen darf aus jedem Knoten, ausgenommen der Quelle, nicht mehr hinausfließen als hinein, eine etwas schwächere Forderung. Daher kommt auch der Name \textit{Vorausfluss}, denn wir dürfen "`zu viel Fluss"' von der Quelle oder einem anderem überlaufenden Knoten vorausschicken, den wir später im Verlauf von Push-Relabel evtl. wieder zurücknehmen müssen. Wir dürfen aber nicht mehr Fluss weiterschicken, als in einem Knoten zur Verfügung steht. Dem Überschuss an eingehendem Fluss geben wir noch einen Namen:

\begin{definition}[Überlauf]\label{ulauf}
	Der Überlauf (auch Überfluss, \textit{engl. excess}) $e(u)$ eines Knotens $u\in V$ ist definiert als
	\[
		e(u) := \sum\limits_{v\in V}f(v,u) - \sum\limits_{v\in V}f(u,v)\text{.}
	\]
\end{definition}

Wenn $e(v) > 0$ für einen Knoten $v \in V \setminus \{s,t\}$, dann sagen wir auch, dass der Knoten überläuft. Die zweite Idee von Push-Relabel neben der Idee vom Vorausfluss besteht darin, den Knoten Höhen zuzuordnen, um dann Fluss generell nur von höheren zu niedrigeren Knoten zu schicken. Dadurch erschaffen wir eine Art Priorität für das Umherschicken von Flussmaterial und laufen nicht Gefahr, endlos Material im Kreis zu transportieren. Erhält man einen überlaufenden Knoten, von dem aus kein Fluss mehr zu Nachbarknoten geschickt werden kann, so setzt man seine Höhe weiter hinauf, um wieder Fluss zu Nachbarknoten schicken zu können. Irgendwann haben wir auf diese Weise das Maximum an Fluss bis zur Senke transportiert und können dann den überschüssigen Fluss der verbleibenden überlaufenden Knoten zurück an die Quelle schicken. Dazu definieren wir uns als nächstes eine Höhenfunktion $h$ wie folgt:

\begin{definition}[Höhenfunktion]\label{hoehe}
	Sei $F = (V,E,c,s,t)$ ein Flussnetzwerk und $f$ ein Vorausfluss in $F$. Eine Funktion $h: V \to \mathbb{N}$ heißt genau dann Höhenfunktion auf $F$, wenn gilt:
	\begin{itemize}
		\item $h(s) = |V|$
		\item $h(t) = 0$
		\item $h(u) \leq h(v) +1$ für jede Residualkante $(u,v)$ des Residualgraphen $F_f$
	\end{itemize}
\end{definition}

\subsection{Das Algorithmentemplate}

\begin{figure}
	\begin{framed}
		\begin{algorithmic}[1]
			\Procedure{PUSH-RELABEL}{F}
			\State INIT	
			\While{es eine anwendbare Push-Operation oder Relabel-Operation gibt}
			\State Wähle eine solche und führe sie aus.
			\EndWhile
			\EndProcedure
		\end{algorithmic}
	\end{framed}
	\caption{PUSH-RELABEL}
	\label{abb:pr}
\end{figure}

Push-Relabel bekommt als Eingabe ein Flussnetzwerk $F=(V,E,c,s,t)$ und arbeitet mit einer Höhenfunktion $h$, einem Vorausfluss $f$ und einer Über\-laufs\-funk\-tion $e$ als Variablen.  Wir wollen den Algorithmus im Folgenden Top-Down darstellen, daher mit der zentralen Schleife beginnen und uns dann zu den zwei Subroutinen genannt "`PUSH"' und "`RELABEL"' abwärts arbeiten. Im Anschluss zeigen wir, dass der Algorithmus das Problem des maximalen Flusses löst.

Abbildung \ref{abb:pr} zeigt die Algorithmenschablone der Push-Relabel-Methode, den zentralen Einstiegspunkt. Hier sieht man auch genau, warum es eine Schablone ist, nämlich legt Push-Relabel keine Reihenfolge fest, wenn mehrere Push- oder Relabel-Operationen anwendbar sind, eine von diesen auszuwählen.


Zuerst, so verrät es uns Abbildung \ref{abb:pr}, wird eine Initialisierung ausgeführt, dargestellt in Abbildung \ref{abb:init}. Die Prozedur INIT muss die eben benannten Variablen auf ihre Startwerte setzen. Dazu setzten wir die Höhe aller Knoten auf $0$ und die Höhe der Quelle auf $|V|$. Wir erstellen einen initialen Vorausfluss, der auf allen Kanten von der Quelle zu einem Knoten maximal ist und damit der Kantenkapazität entspricht und auf allen anderen Kanten $0$. Den Überlauf $e$ setzen wir entsprechend Definition \ref{ulauf}. Insbesondere ist $e(s)$ nach Abschluss der INIT Prozedur die entgegengesetzte Zahl der Summe aller aus der Quelle fließenden Flusseinheiten.

\begin{figure}
	\begin{framed}
\begin{algorithmic}[1]
	\Procedure{INIT}{}
	\ForAll{Knoten $v$}
		\State $h(v):= 0$
		\EndFor
	\State $h(s) := |V|$
	\ForAll{Kanten $(u,v)$}
		\State $f(u,v):= 0$
		\EndFor
	\State $e(s) := 0$
	\ForAll{Knoten $v$}
		\State $f(s,v) := c(s,v)$
		\State $e(v):= c(s,v)$
		\State $e(s) := e(s) - c(s,v)$
	\EndFor
	\EndProcedure
\end{algorithmic}
	\end{framed}
	\caption{INIT}
	\label{abb:init}
\end{figure}

Nun verbleiben die zwei für Push-Relabel wesentlichen und daher auch namensgebenden Operationen PUSH und RELABEL. Diese werden nach Aus\-führ\-ung von INIT solange (in nicht festgelegter Reihenfolge) nacheinander aufgerufen, bis keine von beiden mehr anwendbar ist.

\subsubsection*{Push}

Die Push-Operation ist dazu gedacht Einheiten von einem Knoten zum nächsten zu schieben (\textit{engl. push}). Einheiten werden auf diese Weise Knoten für Knoten in Richtung der Senke geschoben. Dabei wird aus dem bestehenden Vorausfluss ein neuer generiert. Die Überlaufsfunktion $e$ wird entsprechend aktualisiert. Die Höhenfunktion bleibt unverändert.
Push heißt auf einer Kante $(u,v)$ dann und nur dann \textbf{anwendbar}, wenn \begin{itemize}
	\item $c_f(u,v) > 0$,
	\item $u$ überläuft und
	\item $h(u) = h(v) + 1$
\end{itemize}
wobei $c_f(u,v)$ die Residualkapazität der Kante $(u,v)$ im Residualgraphen $F_f$ bezeichnet.

Wenn Push angewandt wird, schickt die Prozedur das Maximum an Einheiten von $u$ nach $v$, welches durch $e(u)$ und $c_f(u,v)$ nach oben beschränkt ist. Abbildung \ref{abb:push} zeigt den Pseudocode für Push. In Abhängigkeit davon, ob das Schieben von Einheiten von $u$ nach $v$ ein Flussvergrößern auf der Kante $(u,v)$ oder ein Verringern auf der Kante $(v,u)$ darstellt, wird der Vorausfluss $f$ entsprechend geändert. Die Abfrage geschieht über $(u,v) \in E$.

\begin{figure}
	\begin{framed}
\begin{algorithmic}[1]
	\Procedure{PUSH}{u,v}
	\State $\Delta := min(e(u),c_f(u,v))$ %\textit{// lokale Variable}
	\If{$(u,v) \in E$}
		\State $f(u,v) := f(u,v) + \Delta$
	\Else
		\State $f(v,u) := f(v,u) - \Delta$
	\EndIf
	\State $e(u) := e(u) - \Delta$
	\State $e(v) := e(v) + \Delta$
	\EndProcedure
\end{algorithmic}	 
	\end{framed}
	\caption{PUSH(u,v)}
	\label{abb:push}
\end{figure}

\subsubsection*{Relabel}

Die Relabel-Operation dient dazu, Knoten zu erhöhen. So nennen wir es auch, wenn der Funktionswert von $h$ für einen Knoten vergrößert wird. Für einen Knoten $u$ wird $h(u)$ minimal erhöht, sodass es danach eine von $u$ wegführende Residualkante $(u,v)$ gibt mit $h(u)>h(v)$. (Daraus folgt direkt als auch mit Definition \ref{hoehe} $h(u)= h(v) +1$.) Äquivalent ausgedrückt wird $h(u)$ so maximal erhöht, dass $h$ eine Höhenfunktion bleibt. Relabel ändert weder die Überlaufs\-funktion $e$ noch den Vorausfluss $f$.

\newpage

Die Relabel Prozedur ist dann und nur dann \textbf{anwendbar}, falls \begin{itemize}
	\item $u$ überläuft und
	\item $h(u) \leq h(v)$ für alle von $u$ ausgehenden Residualkanten $(u,v) \in \mathrm{E}(F_f)$.
\end{itemize}

Abbildung \ref{abb:relabel} zeigt den Pseudocode für Relabel. Die Minimierung über der Menge ist wohldefiniert: Da $u$ überläuft, gilt $e(u)>0$. Weil die Funktionswerte von $f$ nichtnegativ sind, muss es wegen Definition \ref{ulauf} einen Knoten $v$ geben, für den $f(v,u)>0$ gilt. Daher existiert eine Residualkante $(u,v) \in \mathrm{E}(F_f)$ und die Menge $E(F_f)$ ist nicht leer.

\begin{figure}
	\begin{framed}		
	\begin{algorithmic}[1]
		\Procedure{RELABEL}{u}
		\State $h(u) := min\big\{h(v)\mid (u,v)\in \mathrm{E}(F_f)\big\} + 1$
		\EndProcedure
	\end{algorithmic}	 
	\end{framed}
	\caption{RELABEL(u)}
	\label{abb:relabel}
\end{figure}



\subsection{Korrektheit von Push-Relabel}

In diesem Abschnitt wollen wir die Korrektheit von Push-Relabel beweisen. Dazu nehmen wir der Übersichtlichkeit halber zunächst die Beweisstruktur vorweg und gehen erst anschließend auf die Details ein. Unser Ziel formulieren wir in folgendem Satz:

\begin{satz}[Push-Relabel löst Maximum-Flow-Problem]\label{prkorrekt}
	Wird die Push-Re\-la\-bel Methode auf einem Flussnetzwerk $F=(V,E,c,s,t)$ ausgeführt, so gibt der Algorithmus einen maximalen Fluss zurück.
\end{satz}

\newpage

Um diesen Satz zu zeigen, überzeugen wir uns nacheinander davon, dass
\begin{itemize}
	\item $f$ während der Ausführung von PUSH-RELABEL immer ein Vorausfluss ist (Lemma \ref{l:evv}, Erhaltung vom Vorausfluss),
	\item $f$ ein maximaler Fluss ist, falls $f$ ein Vorausfluss ist und PUSH-RELABEL terminiert (Lemma \ref{l:mf}, maximaler Fluss), und dass
	\item PUSH-RELABEL nach endlich vielen Schritten terminiert.
\end{itemize}

Für die ersten zwei Aussagen stellen wir zunächst die Lemmata \ref{l:ofuek} bis \ref{l:kpl} auf, welche sich größtenteils unabhängig voneinander beweisen lassen. Damit wissen wir, dass Push-Relabel bei Terminierung einen maximalen Fluss zurück gibt. Um zu zeigen, dass Push-Relabel definitiv terminieren muss, zeigen wir eine noch stärkere Behauptung, nämlich dass die Methode in $O(V^2 E)$ zeitbeschränkt ist, da wir uns zusätzlich zur Korrektheit auch für die Komplexität von Push-Relabel interessieren und daraus auch gleich die dritte Aussage folgt. Die folgenden Lemmata zeigen den Beweis ausführlich. Abbildung \ref{abb:bstructpr} veranschaulicht vorab einmal die Beweisstruktur.

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{pgfonlayer}{foreground}
		
		\node [cloud] at (-3,5.2) (39) {Max Flow - Min Cut Theorem};
		
		\node [cloud] at (-3,7.8) (45) {Operation für überlaufenden Knoten};
		
		\node [cloud] at (3,7.8) (46) {Höhenwachstum};
		
		\node [cloud] at (-2,6.5) (47) {Erhaltung der Höhenfunktion};
		
		\node [cloud] at (-4.5,2.6) (48) {Kein-Pfad-Lemma};
		
		\node [cloud] at (-3,3.9) (49) {Erhaltung vom Vorausfluss};
		\node [cloud] at (-2,1.3) (410) {maximaler Fluss};
		\node [cloud] at (3,6.5) (411) {Überlauf-Rückfluss-Lemma};
		\node [cloud] at (2,5.2) (412) {Höhenschranke};
		\node [cloud] at (3,3.9) (413) {Schranke für Relabel-Operationen};
		\node [cloud] at (2,2.6) (414) {Schranke für Push-Operationen};
		\node [cloud] at (3,1.3) (415) {Komplexität von PUSH-RELABEL};
		\node [cloud] at (0,0) (44) {Push-Relabel löst Maximum-Flow-Problem};
		\end{pgfonlayer}
		
		\begin{pgfonlayer}{background}
		\path [line] (44) -- (410);
		\path [line] (44) -- (415);
		\path [line] (415) -- (414);
		\path [line] (415) -- (413);
		\path [line] (414) -- (413);
		\path [line] (414) -- (412);
		\path [line] (413) -- (46);
		\path [line] (413) -- (412);
		\path [line] (412) -- (411);
		\path [line] (412) -- (47);
		\path [line] (410) -- (39);
		\path [line] (410) -- (49);
		\path [line] (410) -- (48);
		\path [line] (410) -- (47);
		\path [line] (410) -- (45);
		\path [line] (47) -- (46);
		\end{pgfonlayer}
		
		\end{tikzpicture}
	\end{center}
	\caption{Die Beweisstruktur zu Push-Relabel}
	\label{abb:bstructpr}
\end{figure}

\begin{lemma}[Operation für überlaufenden Knoten]\label{l:ofuek}
	Sei $F$ ein Flussnetzwerk, $f$ ein Vorausfluss in $F$, $h$ eine Höhenfunktion auf $F$ und $u \in \mathrm{V}(F)$ ein überlaufender Knoten. Dann ist RELABEL($u$) anwendbar oder PUSH(u,v) für einen Knoten $v \in \mathrm{V}(F)$.
\end{lemma}
\begin{beweis}
	Angenommen PUSH$(u,v)$ ist für keinen Knoten $v$ anwendbar. Da $h$ eine Höhenfunktion ist, gilt $h(u) \leq h(v) + 1$ für jede Residualkante $(u,v) \in {\rm E}(F_f)$. Da PUSH nicht anwendbar ist, aber $u$ überläuft und $(u,v)$ Residualkante ist, muss $h(u) \neq h(v)+1$ und damit $h(u) \leq h(v)$ für alle Residualkanten $(u,v)$ gelten. Also ist RELABEL auf $u$ anwendbar.
\end{beweis}

\begin{lemma}[Höhenwachstum]\label{l:hw}
	Für einen beliebigen Knoten $v \in V$ gilt, dass $h(v)$ während der Ausführung nie kleiner wird. Wird RELABEL auf $v$ aufgerufen, dann erhöht sich $h(v)$ um mindestens 1.

\end{lemma}
\begin{beweis}
	Wenn RELABEL auf $v$ angewandt wird, dann gilt unmittelbar davor $h(u) \leq h(v)$ für alle aus $v$ ausgehenden Residualkanten. Also ist wegen Zeile~2 des Algorithmus aus Abbildung \ref{abb:relabel} $h(v)$ nach RELABEL mindestens um 1 größer als zuvor. PUSH ändert die Funktion $h$ nicht. Also verkleinert sich $h(v)$ nicht.
\end{beweis}

\begin{lemma}[Erhaltung der Höhenfunktion]\label{l:edh}
	Nach Abschluss der Initialisierung ist während der Ausfüh\-rung von PUSH-RELABEL dessen Zustandsvariable $h$ stets eine Höhenfunktion.
\end{lemma}
\begin{beweis}
	Offensichtlich ist $h$ unmitttelbar nach INIT eine Höhenfunktion, da es keine Residualkante gibt, die aus der Quelle herausführt und alle anderen Knoten die Höhe $null$ zugeordnet bekommen haben. Sei also $h$ eine Höhenfunktion. Es ist zu zeigen, dass diese Eigenschaft eine Invariante bei der Ausführung von sowohl PUSH als auch RELABEL darstellt.
	
	Sei $u$ der Knoten, auf welchem RELABEL ausgeführt wird. Wenn $(u,v)$ eine Residualkante vor der Ausführung von RELABEL$(u)$ war, dann stellt Zeile 2 des Algorithmus RELABEL sicher, dass $h(u)\leq h(v)+1$ nach RELABEL gilt. Wenn dagegen $(v,u)$ eine Residualkante war, dann gilt $h(v) \leq h(u) + 1$ vor RELABEL und wegen Lemma \ref{l:hw} auch danach, denn wir vergößern lediglich $u$ auf der rechten Seite der Ungleichung. Damit erhält RELABEL die o.g. Eigenschaft.
	
	Betrachten wir nun eine Operation PUSH$(u,v)$. Einerseits kann diese mög\-lich\-er\-wei\-se die Residualkante $(u,v)$, welche existieren muss, damit PUSH anwendbar ist, entfernen. Das geschieht dann, wenn der Überfluss von $u$ nicht kleiner als die Restkapazität $c_r(v,v)$ ist. Ein Entfernen einer Residualkante bewirkt das Entfernen der zugehörigen Bedingung laut Definition \ref{hoehe} (Höhenfunktion) und ist unbedenklich. Andererseits kann PUSH$(u,v)$ mög\-lich\-er\-wei\-se die Residualkante $(v,u)$, sofern diese noch nicht schon zuvor existiert hat, hinzufügen. Es gilt $h(u) = h(v) + 1$, d.h. $h(v) = h(u) - 1$, weil PUSH angewandt wurde und daher anwendbar war. Daraus folgt $h(v) \leq h(u) + 1$ und somit ist $h$ auch nach PUSH eine Höhenfunktion.
\end{beweis}

\begin{lemma}[Kein-Pfad-Lemma]\label{l:kpl}
	Sei \ftup ein Flussnetzwerk, $f$ ein Vorausfluss in $F$ und $h$ eine Höhenfunktion auf $F$. Dann existiert im Residualgraphen $F_f$ kein Pfad von der Quelle $s$ zur Senke $t$.
\end{lemma}
\begin{beweis}
	Angenommen es gäbe einen solchen Pfad $p=(s,p_1, \dots p_{n-1},t)$. Dann gilt wegen Definition \ref{hoehe} (Höhenfunktion) für alle Kanten $(p_i,p_{i+1})$ entlang des Pfades $h(p_i) \leq h(p_{i+1}) +1$. In Worten: Die Höhe des Knotens $p_i$ kann sich im Vergleich zum Knoten an Stelle $i+1$ maximal um 1 verringern. Wir starten in der Quelle mit $h(s) = |V|$ und enden in der Senke mit $h(t) = 0$. Damit besteht der Pfad aus mindestens $|V|+1$ paarweise verschiedenen Knoten. Ein Widerspruch.
\end{beweis}

\begin{lemma}[Erhaltung vom Vorausfluss]\label{l:evv}
	Sei $F$ ein Flussnetzwerk, $f$ ein Vorausfluss in $F$ und $h$ eine Höhenfunktion auf $F$. Dann ist nach einer Ausfüh\-rung von PUSH oder RELABEL $f$ wieder ein Vorausfluss.
\end{lemma}
\begin{beweis}
	RELABEL-Operationen ändern die Funktion $f$ nicht und erhalten daher die Vorausflusseigenschaft. Betrachten wir daher im Folgenden eine Operation PUSH$(u,v)$, die Fluss von $u$ nach $v$ schickt. An Zeile 2 der PUSH-Prozedur erkennt man, dass die verfügbare Residualkapazität nicht überschritten wird. Damit erfüllt $f$ wegen der Definition von Residualgraphen nach PUSH die Kapazitätsbedingung. PUSH$(u,v)$ erhöht $e(v)$, was unbedenklich ist und vermindert $e(u)$. Hierbei stellt Zeile 2 wieder sicher, dass $e(u) \geq 0$ nach Ausführung von PUSH. An anderen Knoten oder Kanten ergeben sich keine Änderungen und somit bleibt $f$ ein Vorausfluss.
\end{beweis}

\begin{lemma}[maximaler Fluss]\label{l:mf}
	Sei $F=(V,E,c,s,t)$ ein Flussnetzwerk mit Vorausfluss $f$ und Höhenfunktion $h$. Wenn PUSH-RELABEL terminiert, dann ist $f$ ein maximaler Fluss in $F$.
\end{lemma}
\begin{beweis}
	Aufgrund von Lemma \ref{l:evv} ist $f$ zum Zeitpunkt der Terminierung ein Vorausfluss.
	Wenn PUSH-RELABEL terminiert, dann läuft wegen Lemma \ref{l:ofuek} (Operation für überlaufende Knoten) kein Knoten in $V$ mehr über. D.h. $e(v) = 0$ für alle Knoten $v \in V \setminus \{s,t\}$. Damit erfüllt der $f$ die Flusserhaltung in all diesen Knoten und ist demnach sogar ein Fluss.
	
	Da $h$ laut Lemma \ref{l:edh} (Erhaltung der Höhenfunktion) zum Zeitpunkt der Terminierung eine Höhenfunktion ist, lässt sich Lemma \ref{l:kpl} anwenden, welches uns sagt, dass kein Pfad von $s$ nach $t$ im Residualgraphen existiert. Nach Satz~\ref{mfmct} (Max-flow Min-cut Theorem) ist $f$ ein maximaler Fluss.
\end{beweis}

Nun sind wir an der Stelle, an der wir wissen, dass Push-Relabel nie ein falsches Ergebnis zurückgeben wird, jedoch noch nicht wissen, ob wirklich bei jeder (gültigen) Eingabe ein Ergebnis zurückgegeben wird. Darum widmen wir uns jetzt, wie schon angekündigt, der Komplexität von Push-Relabel. An einer Stelle soll uns die Beweisskizze genügen, um den Rahmen nicht zu sprengen.

\begin{lemma}[Überlauf-Rückfluss-Lemma]\label{l:uerl}
	Es seien $F=(V,E,c,s,t)$ ein Flussnetzwerk und $f$ ein Vorausfluss in diesem. Dann gibt es für jeden überlau\-fen\-den Knoten $v \in V $ einen Pfad $p$ im Residualgraphen $F_f$, sodass $p$ in $v$ beginnt und in der Quelle $s$ endet. 
\end{lemma}

\begin{beweis}
	Stellen wir uns eine Bipartition $(A,B)$ von $V$ vor, in der $A$ alle Knoten enthält, die von $v$ aus im Residualgraphen erreichbar sind, insbesondere $v$ selbst. Nehmen wir zudem an, dass $s\notin A$. Da $v$ überläuft, wäre die Summe aller Überläufe von Knoten in $A$ positiv. Diese Summe wäre außerdem gleich der aufsummierten Flüsse auf Kanten von $B$ nach $A$, abzüglich der von $A$ nach $B$. Dann muss es auch eine Residualkante von $A$ nach $B$ geben, da über irgendeine Kante Flussmaterial von $B$ nach $A$ transportiert wurde. Dann aber existiert ein Knoten in $B$, den wir von $v$ aus erreichen. Ein Widerspruch.
\end{beweis}

\begin{lemma}[Höhenschranke]\label{l:hs}
	Sei $F=(V,E,c,s,t)$ ein Flussnetzwerk. Zu jedem Zeitpunkt der Ausführung von PUSH-RELABEL gilt:
	\[
	 \forall v \in V : 0 \leq h(v) \leq 2|V| -1
	\]
\end{lemma}
\begin{beweis}
	Die Höhen von Quelle und Senke werden anfangs auf die festen Werte $|V|$ beziehungsweise $0$ gesetzt und werden sich nicht ändern, weil Quelle und Senke per Definition nicht überlaufen und deshalb nicht erhöht werden können.
	
	Betrachten wir die restlichen Knoten $v \in V \setminus \{s,t\}$: Anfangs sind deren Höhen auf $0$ gesetzt. Wenn ein solcher Knoten $v$ erhöht wird, dann nur, wenn er überläuft und da RELABEL die Funktionen $f$ und $e$ nicht ändert, läuft $v$ auch nach RELABEL über. Wegen Lemma \ref{l:uerl} gibt es in $F_f$ einen Pfad $p = (p_0, ..., p_n)$ von $p_0 = v$ nach $p_n = s$.
	Nehmen wir $h(v) \geq 2|V|$ an. Jedoch gilt wegen Definition \ref{hoehe} und Lemma \ref{l:edh} für alle Kanten $(p_i,p_{i+1})$ entlang des Pfades $p$, dass $h(p_i) \leq h(p_{i+1}) + 1$. Daher besteht der Pfad aus mindestens $|V| + 1$ Knoten unterschiedlicher Höhe, ein Widerspruch.
\end{beweis}


\begin{lemma}[Schranke für Relabel-Operationen]\label{l:sfro}
	Sei \ftup ein Flussnetzwerk. Dann führt PUSH-RELABEL höchstens $O(|V|^2)$ Relabel-Ope\-ra\-tionen auf $F$ aus.
\end{lemma}
\begin{beweis}
	Wegen des Lemmas von der Höhenschranke (Lemma \ref{l:hs}) und Lemma~\ref{l:hw} wird die Höhe eines Knotens stets um mindestens eins erhöht, wird aber nie größer als $2|V|-1$. Das sind maximal $2|V|-1$ Aufrufe von Relabel für einen Knoten. Es können nur $|V| - 2$ Knoten (Quelle und Senke nämlich nicht) erhöht werden. $(2|V| - 1)(|V| - 2)$ liegt in $O(V^2)$.
\end{beweis}

\begin{lemma}[Schranke für Push-Operationen]\label{l:sfpo}
	Sei $F$ ein Flussnetzwerk. PUSH-RELABEL führt aufgerufen auf $F$ höchstens $O(V^2 E)$ Push-Operationen durch.
\end{lemma}
\begin{beweiss}
	Ein möglicher Beweis beruht auf Lemmata \ref{l:hs} und \ref{l:sfro}. Grob gesagt hilft es, erst sogenannte "`sättigende"' Push-Operationen zu betrachten, d.h. solche, die Residualkanten entfernen. Diese Operationen lassen sich nur auf beschränkt vielen Kanten ausführen, und auf einer Kante unter Einbezug der beiden vorangegangenen Lemmata nicht beliebig oft. Anschließend nimmt man auch die restlichen "`nichtsättigenden"' Push-Operationen hinzu und geht auf ähnliche Weise vor. Auf die Details möchten wir an dieser Stelle verzichten.
\end{beweiss}

\begin{satz}[Komplexität von PUSH-RELABEL]\label{prkompl}
	Die Zahl der Basisoperationen (PUSH und RELABEL) bei der Ausführung der PUSH-RELABEL-Methode auf einem Flussnetzwerk \ftup liegt in $O(V^2 E)$.
\end{satz}
\begin{beweis}
	Die Aussage folgt direkt aus Lemma \ref{l:sfro} und Lemma \ref{l:sfpo}.
\end{beweis}

\begin{beweis}[zu Satz \ref{prkorrekt}]
	Push-Relabel löst das Maximum-Flow-Problem (Lemma \ref{l:mf}) nach endlichen Schritten (Lemma \ref{prkompl}).
\end{beweis}

\section{Vergleich der Methoden}

Zum Abschluss dieser Arbeit wollen wir Ford-Fulkerson und Push-Relabel kurz miteinander vergleichen. Dazu bieten sich die folgenden drei Vergleichskriterien an, von denen die Komplexität wohl die für uns wichtigste und erkenntnisbringenste darstellt, da u.a. diese über den Einsatz in der Praxis entscheiden wird.

\paragraph{Entstehungszeit.}
Der Ford-Fulkerson-Algorithmus wurde 1965 von den US-amerika\-nisch\-en Mathematikern Lester Randolph Ford (junior) und Delbert Ray Fulkerson publiziert und war seiner Zeit der meistgenutzte Algorithmus für das Maximum-Flow-Problem. Zu Recht wird diese Methode daher auch \textit{klassische Methode} zur Lösung dieses Problems genannt.

Erst mehr als 20 Jahre später publizierten im Jahre 1988 Andrew Goldberg und Robert Endre Tarjan den Goldberg-Tarjan-Algorithmus, der auch unter dem hier geführten Namen \textit{Push-Relabel-Algorithmus} bekannt ist und dessen Vorgehen zur Bestimmung eines maximalen Flusses Grundlage für viele heute angewandte und sehr effiziente Implementierungen ist.

\paragraph{Komplexität.}
Ford-Fulkerson hat eine Laufzeit von $O(V \cdot \mathrm{value}(f^*))$, wobei mit $\mathrm{value}(f^*)$ die Größe des \textit{skalierten} maximalen Flusses gemeint ist. Hat das Netzwerk nur ganzzahlige Kapazitäten ist damit einfach der Fluss selbst und dessen Wert gemeint. Gibt es rationale Zahlen als Kapazitäten, so lassen sich diese mit einer Konstanten "`wegmultiplizieren"', sodass nur noch ganzzahlige Kapazitäten vorherrschen und nach der Ausführung von Ford-Fulkerson lässt sich das Ergebnis wieder rücktransformieren.
Eine spezielle Version von dem Template Ford-Fulkerson ist der Edmonds-Karp-Algorithmus. Dieser schafft eine Laufzeit von $O(VE^2)$, indem er kürzeste augmentierende Pfade berechnet.

Push-Relabel läuft in einer Zeit von $O(V^2 E)$. Eine spezielle Implementierung, die sich hier Relabel-To-Front nennt und darauf basiert, die Knoten in eine Liste zu schreiben, sie der Reihe nach abzuarbeiten und Knoten nach einem Relabel-Vorgang an den Anfang der Liste zu packen, läuft sogar in $O(V^3)$.

\paragraph{Abdeckung.}
Bei Ford-Fulkerson darf man die reellen Zahlen leider nicht ganz ausschöp\-fen. Gibt es im Flussnetzwerk irrationale Kantenkapazitäten, so ist für Ford-Fulkerson nicht mehr generell gewährleistet, dass das Verfahren auch tat\-säch\-lich terminiert. Ein minimales Beispiel dazu mit 6 Knoten und 8 Kanten hat Uri Zwick im Jahr 1993 publiziert \cite{Zwi93}, auch Ford und Fulkerson selbst konstruierten zuvor ein Beispiel mit 10 Knoten und 48 Kanten. Zwick wählte dazu eine geeignete unendliche Zahlenfolge aus und zeigte einen Verlauf von Ford-Fulkerson auf, der nach jedem Schritt der Flussverbesserung, jeweils das nächste Folgenglied mitberechnet hat.
Mit Edmonds-Karp lässt sich dieses Problem allerdings, ohne die algorithmische Herangehensweise von Ford-Fulkerson verwerfen zu müssen, umgehen. In diesem Sinne ist es innerhalb der Schranken des Ford-Fulkerson-Templates möglich, auch im reellen zu terminieren und das in der Komplexität sogar unabhängig von der Größe des maximalen Flusses.

Push-Relabel dagegen terminiert ohne Einschränkungen auf jeg\-lich\-en Flussnetzwerken gemäß unserer Definition und deckt damit von vornherein alle Fälle ab. Insbesondere löst daher auch Relabel-To-Front das Problem auf Flussnetzwerken sowohl mit als auch ohne irrationale Kapazitäten.

\medskip
In der Praxis würden uns \textit{vermutlich} auch rationale Kapazitäten ausreichen. Für diese irrationale Zahlen zu fordern, hieße dann, von einer unbeschränkten Genauigkeit auszugehen. Das ist zumindest in allen praxisbezogenen Kontexten unnötig oder gar unbegründet, in denen reale Messfehler in die Kantenkapazitäten eingehen bzw. in welchen wir die üblichen Gleitkommadarstellungen realer Rechner verwenden. Es kann stattdessen auf nächstgelegene rationale Werte gerundet und mit ohnehin schon eingeschränkter Genauigkeit gerechnet werden.

\begin{thebibliography}{99}
	\bibitem{CLR09}[CLR09] \textit{T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein.}
						Introduction to Algorithms. Third Edition. The MIT Press, 2009.
	\bibitem{Zwi93}[Zwi93] \textit{Uri Zwick.} The smallest networks on which the Ford-Fulkerson maximum flow procedure may fail to terminate. 1993.
\end{thebibliography}

\end{document}